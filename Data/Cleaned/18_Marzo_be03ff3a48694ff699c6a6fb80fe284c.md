# 18 Marzo

Argomenti: Accesso diretto, Merge sort esterno, Ordinamento, Scansione
.: No

## Esecuzione delle operazioni

I `DMBS` offrono operatori che implementano ciascuno uno o più operatori dell’algebra gli operatori fondamentali sono 4 e sono: `scansione`,`accesso-diretto`,`ordinamento` e `join`.

## Scansione

L’operazione di `scansione` serve sostanzialmente a realizzare l’accesso sequenziale ad un file,relazione e tabella avendo sempre una posizione corrente ed eseguendo le operazioni a partire da questa posizione corrente.

Intuitivamente le funzioni dell’API possono essere: `open`,`next`,`read`,`modify`,`insert`,`delete` e `close`. Il costo è lineare rispetto al numero di blocchi del file.

## Accesso diretto

Può essere eseguito solo se le strutture fisiche lo permettono, ci sono 2 modi per farlo: con gli `indici` e le `strutture hash`.

L’accesso diretto basato su indice è efficiente per ricerche sul campo su cui l’indice è realizzato cioè sulla chiave dell’indice, soprattutto nelle ricerche `puntuali` (ricerca su tutto il campo → ricerca di numero matricola), ricerche `su intervallo` (ricerca non su tutto il campo) purchè l’indice sia `selettivo`.

L’accesso diretto basato su hash è efficiente per interrogazioni che non si basano su intervallo ma solo puntuali.

## Ordinamento

L’`ordinamento` è importante per produrre risultati ordinati, eliminare duplicati, preparare aggregazioni e preparare i join. Questa operazione utilizza significativamente i buffer.

![Screenshot from 2024-03-18 14-13-43.png](Screenshot_from_2024-03-18_14-13-43.png)

si suppone che si voglia fare un ordinamento di un file grande

L’ordinamento tradizionale di file usa un `merge-sort` esterno in memoria secondaria e “poca” memoria principale

## Esempio con merge-sort (classico) [3 buffer]

![Screenshot from 2024-03-18 15-07-51.png](Screenshot_from_2024-03-18_15-07-51.png)

Si hanno 2 porzioni da fondere; si prendono i primi blocchi di entrambi le porzioni e lo si mettono nel buffer.

![Screenshot from 2024-03-18 15-09-33.png](Screenshot_from_2024-03-18_15-09-33.png)

Visto che sono ordinati il valore minimo di questi blocchi è l’elemento affiorante quindi 16 e poi avanzando si ottiene che il valore minimo è 17

(Gli elementi affiorianti si vedono nella “freccia rossa” nel buffer)

A questo punto il buffer è pieno quindi si sovrascrive il primo blocco.

![Screenshot from 2024-03-18 15-13-28.png](Screenshot_from_2024-03-18_15-13-28.png)

Continuando la visita si ottiene che 25 è il valore minimo e lo si scrive nel terzo buffer. Adesso succede che il secondo buffer è stato completamente utilizzato

![Screenshot from 2024-03-18 15-14-42.png](Screenshot_from_2024-03-18_15-14-42.png)

Quindi si può prendere il blocco successivo e caricarlo in memoria

![Screenshot from 2024-03-18 15-15-21.png](Screenshot_from_2024-03-18_15-15-21.png)

L’elemento affiorante tra 27 e 36 è 27 quindi lo si scrive nel buffer

![Screenshot from 2024-03-18 15-17-23.png](Screenshot_from_2024-03-18_15-17-23.png)

Si aggiunge il terzo buffer nella lista delle posizioni ordinate e poi si sceglie l’elemento affiorante fra 36 e 47 che è 36

![Screenshot from 2024-03-18 15-19-35.png](Screenshot_from_2024-03-18_15-19-35.png)

il primo buffer è stato completamente utilizzato quindi si libera e viene caricata l’altro blocco

Da qui il ragionamento è semplice

## Esempio con merge-sort (esterno) [3 buffer]

![Screenshot from 2024-03-18 15-21-37.png](Screenshot_from_2024-03-18_15-21-37.png)

Il `merge-sort` esterno viene di solito presentato “top-down”, utilizzando il ragionamento con il merge sort (classico) si ragiona come se il file fosse composto di tante porzioni.

Quindi si ordinano porzioni via via più lunghe fino ad arrivare all’intero file

## Esempio con merge-sort (esterno) [5 buffer]

![Screenshot from 2024-03-18 15-26-47.png](Screenshot_from_2024-03-18_15-26-47.png)

Esempio con merge a 4 vie quindi si fondono 4 liste. In pratica si caricano i primi blocchi delle 4 liste nei 4 buffer, usando il quinto buffer per l’ordinamento/merge

## Merge-sort in sintesi

In moltissimi casi basta fare 2 passate, quindi un ordinamento e un passo di merge successivo con un costo pari a 3 volte il numero di blocchi del file avendo a disposizione un numero di pagine di buffer pari almeno alla radice quadrata del numero di blocchi del file.

## Join

L’operazione di `join` è quella più costosa, ci sono vari metodi i più noti sono `nested-loop`,`merge-join` e `hash-join`.

## Nested loop

![Screenshot from 2024-03-18 15-44-38.png](Screenshot_from_2024-03-18_15-44-38.png)

Si suppone di avere 2 relazioni $R1$ e $R2$, e si suppone di dover fare il join sui campi che hanno gli stessi valori.

![Screenshot from 2024-03-18 15-47-56.png](Screenshot_from_2024-03-18_15-47-56.png)

Per eseguire il join senza usare gli indici, si leggono tutti i record della prima tabella e per ciascun record della tabella si dovrebbe fare una scansione per la seconda tabella.

$$
B_1+B_1\cdot B_2
$$

Il costo della scansione è la somma di $B_1$ (costo associato alla lettura del primo file) e $B_1\cdot B_2$ cioè il secondo file dovrà essere letto $B_1$ volte

Si può però ridurre il numero di lettura del secondo file cercando di caricare più porzioni possibili del primo file in memoria, cosi da poter fare solamente le scansioni del secondo file, cosi da ridurre il numero di scansioni del secondo file.