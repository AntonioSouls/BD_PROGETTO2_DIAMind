# 15 Novembre

Argomenti: Metodi di ricerca locale, Ricerca Locale per il TSP
.: Yes

## Algoritmi euristici

Gli `algoritmi euristici` possono essere anche classificati come segue:

- `algoritmi costruttivi`: sfruttano le proprietà strutturali delle soluzioni ammissibili
- `algoritmi di ricerca locale`: ricerca nello spazio delle soluzioni modificando leggermente la struttura di soluzioni già note
- `metaeuristiche`: estendono la ricerca locale

## Metodi di ricerca locale

Questi metodi fanno parte degli algoritmi euristici, dove per creare una soluzione si fa una ricerca nello spazio delle soluzioni ammissibili già note modificandogli leggermente la struttura. Si basa sull’approccio più semplice della ottimizzazione: `andare a tentativi`.

Un esempio è di avere un problema di minimizzazione con $x$ soluzione ammissibile e $f(x)$ valore funzione obbiettivo. L’idea di base è definire il vicinato di $x$ detto $N(x)$ ed esplorare tale vicinato in cerca di soluzioni migliori di quella corrente. Da qui si hanno 2 casi:

- Se in $N(x)$ si scopre una soluzione $x'$ con $f(x')\lt f(x)$ allora ci si sposta da $x$ a $x'$ e si riparte da $x'$ con l’esplorazione del suo vicinato
- se invece nel vicinato di $x'$ non esiste una soluzione tale che $f(x')<f(x)$ allora si dice che $x'$ è un `minimo locale`.

Il problema di questo algoritmo è che quando si ferma restituisce o un minimo `locale` o un minimo `globale`.

Un modo per rappresentare graficamente l’andamento della ricerca locale è il `search graph`, dove i nodi rappresentano le soluzioni ammissibili e gli archi rappresentano come arrivare ai nodi del vicinato $N(x)$.

Le scelte iniziali per una ottima ricerca locale sono:

- Iniziare con una soluzione `iniziale ammissibile` generata da una euristica per il particolare problema oppure iniziare da una soluzione generata casualmente.
- Definire il `vicinato` in modo chiaro e preciso, perché se vengono definite in un certo modo allora aumenta la qualità delle soluzioni prodotte dall’algoritmo rendendo indipendente le nuove soluzioni da quella di partenza.
- Occorre avere un algoritmo per l’`esplorazione` del vicinato. Ci sono 2 metodi:
    - `first improvement`: il quale termina non appena si trova una soluzione migliore di quella corrente
    - `steepest ascent`: si esplora tutto cercando il massimo miglioramento che quel vicinato consente di ottenere

## Ricerca locale per il TSP

Sia $G$ un grafo non orientato e sia $n$ il numero di nodi, il vicinato lo si crea facendo i cosiddetti  `k-scambi`, partendo da una soluzione ammissibile, il vicinato è costituito da tutte le soluzioni ottenute cancellando $k$ archi (non adiacenti) e sostituendoli con altri `k` in modo da ricreare un ciclo. Il vicinato viene chiamato `K-OTP`.

## Metodi di ricerca locale a profondità variabile

L’idea di base è che il numero di scambi usato per passare dalla soluzione corrente alla successiva NON è fissato a priori. Per passare da una soluzione $x$ a una soluzione $y$ si applicano $t$ mosse (dove $t$ dipende dalla soluzione corrente $x$) ottenendo una sequenza di soluzioni $x_1,x_2,...,x_t$ e scegliendo la migliore fra queste.

Per ottenere la soluzione migliore di questa sequenza si utilizza una funzione che indica il guadagno ottenibile per ogni sequenza di scambi. La lunghezza della sequenza generata viene determinata utilizzando un criterio di arresto appropriato

## Partizione uniforme di grafi

Si consideri un grafo $G=(V;E)$ non orientato con $|V|=2n$ vertici, pesato sugli archi con pesi $w_{ij}$. Una partizione $(A;B)$ dell’insieme dei vertici si dice `uniforme` se $|A|=|B|$. Trovare la partizione uniforme di costo minimo è stato dimostrato essere un problema NP-completo